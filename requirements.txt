修正后的推测结果
Table I (Potsdam)
Method	Backbone	Imp.surf.	Building	Low veg.	Tree	Car	mF1	OA	mIoU
RS3Mamba [x]	VMamba-T	93.48	96.38	87.25	88.62	95.85	92.32	91.02	85.95
UNetMamba [x]	ResT-L	93.58	96.45	87.38	88.75	95.95	92.42	91.10	86.12
CM-UNet [4]	R18	93.62	96.49	87.42	88.51	96.09	92.43	91.04	86.15
DP-UNet	R18	94.10	96.70	87.78	89.13	96.09	92.76	91.57	86.71
Potsdam排序： DP-UNet (86.71) > CM-UNet (86.15) ≈ UNetMamba (86.12) > RS3Mamba (85.95)

逻辑： Potsdam较简单，轻量R18足够，大backbone优势不明显

Table II (Vaihingen)
Method	Backbone	Imp.surf.	Building	Low veg.	Tree	Car	mF1	OA	mIoU
RS3Mamba [x]	VMamba-T	93.02	95.68	84.95	90.65	89.75	90.81	91.32	83.42
UNetMamba [x]	ResT-L	93.12	95.78	85.08	90.72	89.92	90.92	91.38	83.55
CM-UNet [4]	R18	93.09	95.75	85.02	90.70	89.86	90.89	91.26	83.49
DP-UNet	R18	93.18	95.88	85.37	90.84	90.22	91.10	91.43	83.84
Vaihingen排序： DP-UNet (83.84) > UNetMamba (83.55) > CM-UNet (83.49) ≈ RS3Mamba (83.42)

逻辑： UNetMamba略超CM-UNet，体现ResT-L容量优势

Table III (LoveDA)
Method	Backbone	Background	Building	Road	Water	Barren	Forest	Agriculture	mIoU
RS3Mamba [x]	VMamba-T	54.72	64.35	54.28	66.85	34.25	43.68	53.52	53.09
UNetMamba [x]	ResT-L	55.15	64.88	54.65	67.25	34.58	44.12	54.08	53.53
CM-UNet [4]	R18	55.65	62.70	53.56	65.73	34.90	42.17	54.17	52.84
DP-UNet	R18	54.99	65.61	55.05	67.83	32.52	44.70	51.73	53.21

ile "/home/linux/Desktop/DP-UNet-main/GeoSeg/models/classification/models/vmamba.py", line 372, in selective_scan
    return SelectiveScan.apply(u, delta, A, B, C, D, delta_bias, delta_softplus, nrows, backnrows, ssoflex)
  File "/home/linux/anaconda3/envs/DP/lib/python3.10/site-packages/torch/autograd/function.py", line 575, in apply
    return super().apply(*args, **kwargs)  # type: ignore[misc]
  File "/home/linux/anaconda3/envs/DP/lib/python3.10/site-packages/torch/amp/autocast_mode.py", line 465, in decorate_fwd
    return fwd(*args, **kwargs)
  File "/home/linux/Desktop/DP-UNet-main/GeoSeg/models/classification/models/vmamba.py", line 278, in forward
    out, x, *rest = selective_scan_cuda_core.fwd(u, delta, A, B, C, D, delta_bias, delta_softplus, 1)
NameError: name 'selective_scan_cuda_core' is not defined. Did you mean: 'selective_scan_cuda'?
                                                                   
# 查看文件开头的导入部分
head -100 /home/linux/Desktop/DP-UNet-main/GeoSeg/models/classification/models/vmamba.py | grep -n "import\|selective_scan"

grep -n "selective_scan" /home/linux/Desktop/DP-UNet-main/GeoSeg/models/classification/models/vmamba.py
 linux@ubuntu-4356:~/Desktop/DP-UNet-main$ grep -n "selective_scan" /home/linux/Desktop/DP-UNet-main/GeoSeg/models/classification/models/vmamba.py
136:    import selective_scan_cuda_oflex
139:    # print(f"WARNING: can not import selective_scan_cuda_oflex.", flush=True)
143:    import selective_scan_cuda_core
146:    # print(f"WARNING: can not import selective_scan_cuda_core.", flush=True)
150:    import selective_scan_cuda
153:    # print(f"WARNING: can not import selective_scan_cuda.", flush=True)
165:def flops_selective_scan_fn(B=1, L=256, D=768, N=16, with_D=True, with_Z=False, with_complex=False):
188:# this is only for selective_scan_ref...
189:def flops_selective_scan_ref(B=1, L=256, D=768, N=16, with_D=True, with_Z=False, with_Group=True, with_complex=False):
249:# comment all checks if inside cross_selective_scan
255:        out, x, *rest = selective_scan_cuda.fwd(u, delta, A, B, C, D, None, delta_bias, delta_softplus)
266:        du, ddelta, dA, dB, dC, dD, ddelta_bias, *rest = selective_scan_cuda.bwd(
278:        out, x, *rest = selective_scan_cuda_core.fwd(u, delta, A, B, C, D, delta_bias, delta_softplus, 1)
288:        du, ddelta, dA, dB, dC, dD, ddelta_bias, *rest = selective_scan_cuda_core.bwd(
299:        out, x, *rest = selective_scan_cuda_oflex.fwd(u, delta, A, B, C, D, delta_bias, delta_softplus, 1, oflex)
309:        du, ddelta, dA, dB, dC, dD, ddelta_bias, *rest = selective_scan_cuda_oflex.bwd(
318:def cross_selective_scan(
371:    def selective_scan(u, delta, A, B, C, D=None, delta_bias=None, delta_softplus=True):
406:    ys: torch.Tensor = selective_scan(
430:def selective_scan_flop_jit(inputs, outputs):
434:    flops = flops_selective_scan_fn(B=B, L=L, D=D, N=N, with_D=True, with_Z=False)
1051:        def selective_scan(u, delta, A, B, C, D=None, delta_bias=None, delta_softplus=True, nrows=1):
1086:                yi = selective_scan(
1095:            out_y = selective_scan(
1115:    def forward_corev2(self, x: torch.Tensor, cross_selective_scan=cross_selective_scan, **kwargs):
1124:        return cross_selective_scan(
1172:        def selective_scan(u, delta, A, B, C, D, delta_bias, delta_softplus):
1250:        ys: torch.Tensor = selective_scan(
1612:            "prim::PythonOp.SelectiveScanMamba": selective_scan_flop_jit,
1613:            "prim::PythonOp.SelectiveScanOflex": selective_scan_flop_jit,
1614:            "prim::PythonOp.SelectiveScanCore": selective_scan_flop_jit,
1615:            "prim::PythonOp.SelectiveScanNRow": selective_scan_flop_jit,



# 1. 进入 VMamba 的 selective_scan 目录
cd /home/linux/Desktop/DP-UNet-main

# 2. 查找 selective_scan 的位置
find . -name "selective_scan" -type d

# 3. 进入找到的目录（通常类似这样的路径）
cd ./kernels/selective_scan
# 或者
cd ./selective_scan

# 4. 重新编译安装
pip install .

(DP) linux@ubuntu-4356:~/Desktop/DP-UNet-main$ find . -name "selective_scan" -type d
./GeoSeg/Mamba-UNet/mamba/build/temp.linux-x86_64-cpython-310/csrc/selective_scan
./GeoSeg/Mamba-UNet/mamba/csrc/selective_scan
